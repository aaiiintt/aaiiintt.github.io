<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Cherry Blossom Flow</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1; /* Place canvas behind other content */
        }
        .content {
            color: #333; /* Dark text for light background */
            font-family: sans-serif;
            text-align: center;
            padding-top: 20vh;
            position: relative; /* Ensure content is on top */
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="content">
        <h1>Your Website Title</h1>
        <p>This is some example content on top of the background.</p>
    </div>

    <!-- Three.js, NoiseJS, and dat.GUI libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script>
        let scene, camera, renderer, particles;
        let noise = new Noise(Math.random());

        const cherryBlossomPalette = [
            new THREE.Color('#FFB7C5'), // Light Pink
            new THREE.Color('#FFC0CB'), // Pink
            new THREE.Color('#FFD1DC'), // Pale Pink
            new THREE.Color('#FFFFFF'), // White
            new THREE.Color('#F8AFA6')  // Light Coral
        ];

        const settings = {
            particleCount: 6000,
            particleSize: 0.02,
            backgroundColor: '#FFFFFF',
            noiseSpeed: 0.0008,
            noiseScale: 1.2,
            particleSpeed: 0.015,
            trailLength: 0.15, // Higher value = shorter trails on light bg
            regenerate: () => {
                if (particles) scene.remove(particles);
                createParticles();
            },
            recolor: () => {
                if (particles) assignColors();
            }
        };

        function assignColors() {
            const colors = new Float32Array(settings.particleCount * 3);
            for (let i = 0; i < settings.particleCount; i++) {
                const color = cherryBlossomPalette[Math.floor(Math.random() * cherryBlossomPalette.length)];
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            particles.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.geometry.attributes.color.needsUpdate = true;
        }

        function createParticles() {
            const positions = new Float32Array(settings.particleCount * 3);
            const geometry = new THREE.BufferGeometry();

            for (let i = 0; i < settings.particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 10;
                positions[i3 + 1] = (Math.random() - 0.5) * 10;
                positions[i3 + 2] = (Math.random() - 0.5) * 10;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: settings.particleSize,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8,
                vertexColors: true 
            });

            particles = new THREE.Points(geometry, material);
            assignColors(); 
            scene.add(particles);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(new THREE.Color(settings.backgroundColor));
            renderer.autoClearColor = false;
            document.body.appendChild(renderer.domElement);
            document.body.style.backgroundColor = settings.backgroundColor;

            createParticles();
            
            const trailPlaneGeo = new THREE.PlaneGeometry(20, 20);
            const trailPlaneMat = new THREE.MeshBasicMaterial({
                // FIX: Initialize the color correctly using a THREE.Color object
                color: new THREE.Color(settings.backgroundColor),
                transparent: true,
                opacity: settings.trailLength
            });
            const trailPlane = new THREE.Mesh(trailPlaneGeo, trailPlaneMat);
            scene.add(trailPlane);

            window.addEventListener('resize', onWindowResize, false);
            setupGUI(trailPlaneMat);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * settings.noiseSpeed;
            const positions = particles.geometry.attributes.position.array;

            for (let i = 0; i < settings.particleCount; i++) {
                const i3 = i * 3;
                const noiseVal = noise.perlin3(positions[i3] * settings.noiseScale, positions[i3 + 1] * settings.noiseScale, time);
                const angle = noiseVal * Math.PI * 2;

                positions[i3] += Math.cos(angle) * settings.particleSpeed;
                positions[i3 + 1] += Math.sin(angle) * settings.particleSpeed;

                if (positions[i3] > 5) positions[i3] = -5;
                if (positions[i3] < -5) positions[i3] = 5;
                if (positions[i3+1] > 5) positions[i3+1] = -5;
                if (positions[i3+1] < -5) positions[i3+1] = 5;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function setupGUI(trailMaterial) {
            const gui = new dat.GUI();
            const appearanceFolder = gui.addFolder('Appearance');
            appearanceFolder.addColor(settings, 'backgroundColor').onChange(() => {
                const newColor = new THREE.Color(settings.backgroundColor);
                renderer.setClearColor(newColor);
                trailMaterial.color.set(newColor);
                document.body.style.backgroundColor = settings.backgroundColor;
            });
            appearanceFolder.add(settings, 'particleSize', 0.001, 0.1).onChange(() => {
                particles.material.size = settings.particleSize;
            });
            
            const animationFolder = gui.addFolder('Animation');
            animationFolder.add(settings, 'noiseSpeed', 0.0001, 0.005);
            animationFolder.add(settings, 'noiseScale', 0.1, 5.0);
            animationFolder.add(settings, 'particleSpeed', 0.001, 0.1);
            animationFolder.add(settings, 'trailLength', 0.01, 0.5).onChange(() => {
                trailMaterial.opacity = settings.trailLength;
            });

            gui.add(settings, 'particleCount', 1000, 20000).step(100);
            gui.add(settings, 'regenerate').name('Regenerate Particles');
            gui.add(settings, 'recolor').name('Recolor Particles');
        }

        init();
        animate();
    </script>
</body>
</html>
