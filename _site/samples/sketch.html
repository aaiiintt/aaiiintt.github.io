<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Undulating Text Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #p5-container {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
    </style>
    <!-- p5.js, Tone.js, and NoiseJS libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js"></script>
</head>
<body>
    <div id="p5-container"></div>

    <script>
        const sketch = (p) => {
            let letters = [];
            const initialString = "iain tait";
            const sortedString = "aaiiintt";
            let isSorted = false;
            let container;
            let synth, reverb, delay;
            let noise = new Noise(Math.random());
            let phase = 0;

            // --- Settings for the wave motion ---
            const waveSettings = {
                amplitude: 15, // How high/low the wave goes
                zoom: 0.01,    // How stretched out the wave is
                speed: 0.005   // How fast the wave moves
            };

            class Letter {
                constructor(char, initialPos, sortedPos) {
                    this.char = char;
                    this.initialPos = initialPos.copy();
                    this.sortedPos = sortedPos.copy();
                    
                    this.pos = initialPos.copy();
                    this.target = initialPos.copy();
                    this.vel = p.createVector(0, 0);
                    this.acc = p.createVector(0, 0);

                    // Animation properties for sorting
                    this.maxSpeed = p.random(4, 8);
                    this.maxForce = p.random(0.1, 0.2);
                    this.slowingRadius = 150;
                    this.color = p.color('#1A1A1A');
                }

                // This function now ONLY handles the sorting position logic.
                // The drawing is handled separately in the main draw loop.
                update() {
                    let desired = p5.Vector.sub(this.target, this.pos);
                    let distance = desired.mag();
                    if (distance > 1) {
                        let speed = this.maxSpeed;
                        if (distance < this.slowingRadius) {
                            speed = p.map(distance, 0, this.slowingRadius, 0, this.maxSpeed);
                        }
                        desired.setMag(speed);
                        let steer = p5.Vector.sub(desired, this.vel);
                        steer.limit(this.maxForce);
                        this.acc.add(steer);
                    }
                    this.vel.add(this.acc);
                    this.vel.limit(this.maxSpeed);
                    this.pos.add(this.vel);
                    this.acc.mult(0);
                }
            }

            p.setup = () => {
                container = document.getElementById('p5-container');
                let canvas = p.createCanvas(container.clientWidth, 250);
                canvas.parent('p5-container');
                p.textFont('Arial');
                p.textAlign(p.CENTER, p.CENTER);

                // Setup sound
                reverb = new Tone.Reverb({ decay: 4, wet: 0.8 }).toDestination();
                delay = new Tone.FeedbackDelay("8n", 0.4).connect(reverb);
                synth = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 2 }
                }).connect(delay);

                initializeLetters();
            };

            p.windowResized = () => {
                p.resizeCanvas(container.clientWidth, 250);
                initializeLetters();
            };

            p.draw = () => {
                p.clear();
                p.textStyle(p.BOLD);
                p.textSize(100);

                // Update letter positions for sorting, then draw them along the wave
                for (let letter of letters) {
                    letter.update();

                    // --- Wave Calculation for each letter's baseline ---
                    const noiseVal = noise.perlin2(letter.pos.x * waveSettings.zoom, phase);
                    const yOffset = p.map(noiseVal, -1, 1, -waveSettings.amplitude, waveSettings.amplitude);

                    // Calculate rotation to make the letter follow the wave's curve
                    const nextNoiseVal = noise.perlin2((letter.pos.x + 1) * waveSettings.zoom, phase);
                    const nextYOffset = p.map(nextNoiseVal, -1, 1, -waveSettings.amplitude, waveSettings.amplitude);
                    const rotation = p.atan2(nextYOffset - yOffset, 1);

                    p.push();
                    p.translate(letter.pos.x, letter.pos.y + yOffset);
                    p.rotate(rotation);
                    p.fill(letter.color);
                    p.noStroke();
                    p.text(letter.char, 0, 0);
                    p.pop();
                }
                
                phase += waveSettings.speed;
            };

            const playSound = () => {
                if (Tone.context.state !== 'running') {
                    Tone.context.resume();
                }
                // By passing Tone.now(), we explicitly schedule the event at the current audio context time,
                // which prevents scheduling conflicts on rapid clicks.
                synth.triggerAttackRelease('C2', '1n', Tone.now());
            };

            const toggleAnimation = () => {
                playSound();
                isSorted = !isSorted;
                for (let letter of letters) {
                    letter.target = isSorted ? letter.sortedPos : letter.initialPos;
                    letter.vel = p5.Vector.random2D().mult(p.random(2, 6));
                }
            };
            
            p.mousePressed = () => {
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    toggleAnimation();
                }
            };

            p.touchStarted = () => {
                if (p.touches.length > 0) {
                    const touchX = p.touches[0].x;
                    const touchY = p.touches[0].y;
                    if (touchX > 0 && touchX < p.width && touchY > 0 && touchY < p.height) {
                        toggleAnimation();
                        return false;
                    }
                }
            };

            const initializeLetters = () => {
                letters = [];
                let initialPositions = calculatePositions(initialString);
                let sortedPositions = calculatePositions(sortedString);
                let usedSortedIndices = {};

                for (let i = 0; i < initialString.length; i++) {
                    let char = initialString[i];
                    if (char === ' ') continue;

                    let targetIndex = -1;
                    for (let j = 0; j < sortedString.length; j++) {
                        if (sortedString[j] === char && !usedSortedIndices[j]) {
                            targetIndex = j;
                            usedSortedIndices[j] = true;
                            break;
                        }
                    }

                    if (targetIndex !== -1) {
                        let initialPos = initialPositions[i];
                        let sortedPos = sortedPositions[targetIndex];
                        letters.push(new Letter(char, initialPos, sortedPos));
                    }
                }
                setTimeout(toggleAnimation, 500);
            };

            function calculatePositions(str) {
                let positions = [];
                p.textSize(100);
                p.textStyle(p.BOLD);
                let currentX = 0;
                let y = p.height / 2;
                for (let char of str) {
                    let charWidth = p.textWidth(char);
                    positions.push(p.createVector(currentX + charWidth / 2, y));
                    currentX += charWidth;
                }
                return positions;
            }
        };

        new p5(sketch);
    </script>
</body>
</html>
